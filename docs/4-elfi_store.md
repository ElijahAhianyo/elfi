# Elfi Store

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-Codebase Structure-start--->
## Codebase Structure

<!---Documatic-block-system_architecture-start--->
```mermaid
None
```
<!---Documatic-block-system_architecture-end--->

# #
<!---Documatic-section-Codebase Structure-end--->

<!---Documatic-section-elfi.store.ArrayPool-start--->
## [elfi.store.ArrayPool](4-elfi_store.md#elfi.store.ArrayPool)

<!---Documatic-section-ArrayPool-start--->
<!---Documatic-block-elfi.store.ArrayPool-start--->
<details>
	<summary><code>elfi.store.ArrayPool</code> code snippet</summary>

```python
class ArrayPool(OutputPool):

    def _make_store_for(self, node):
        if not self.has_context:
            raise ValueError('ArrayPool has no context set')
        os.makedirs(self.path, exist_ok=True)
        filename = os.path.join(self.path, node)
        return NpyStore(filename, self.batch_size)
```
</details>
<!---Documatic-block-elfi.store.ArrayPool-end--->
<!---Documatic-section-ArrayPool-end--->

# #
<!---Documatic-section-elfi.store.ArrayPool-end--->

<!---Documatic-section-elfi.store.OutputPool-start--->
## [elfi.store.OutputPool](4-elfi_store.md#elfi.store.OutputPool)

<!---Documatic-section-OutputPool-start--->
<!---Documatic-block-elfi.store.OutputPool-start--->
<details>
	<summary><code>elfi.store.OutputPool</code> code snippet</summary>

```python
class OutputPool:
    _pkl_name = '_outputpool.pkl'

    def __init__(self, outputs=None, name=None, prefix=None):
        """Initialize OutputPool.

        Depending on the algorithm, some of these values may be reused
        after making some changes to `ElfiModel` thus speeding up the inference
        significantly. For instance, if all the simulations are stored in Rejection
        sampling, one can change the summaries and distances without having to rerun
        the simulator.

        Parameters
        ----------
        outputs : list, dict, optional
            List of node names which to store or a dictionary with existing stores. The
            stores are created on demand.
        name : str, optional
            Name of the pool. Used to open a saved pool from disk.
        prefix : str, optional
            Path to directory under which `elfi.ArrayPool` will place its folder.
            Default is a relative path ./pools.

        Returns
        -------
        instance : OutputPool

        """
        if outputs is None:
            stores = {}
        elif isinstance(outputs, dict):
            stores = outputs
        else:
            stores = dict.fromkeys(outputs)
        self.stores = stores
        self.batch_size = None
        self.seed = None
        self.name = name
        self.prefix = prefix or _default_prefix
        if self.path and os.path.exists(self.path):
            raise ValueError('A pool with this name already exists in {}. You can use OutputPool.open() to open it.'.format(self.prefix))

    @property
    def output_names(self):
        """Return a list of stored names."""
        return list(self.stores.keys())

    @property
    def has_context(self):
        """Check if current pool has context information."""
        return self.seed is not None and self.batch_size is not None

    def set_context(self, context):
        """Set the context of the pool.

        The pool needs to know the batch_size and the seed.

        Notes
        -----
        Also sets the name of the pool if not set already.

        Parameters
        ----------
        context : elfi.ComputationContext

        """
        if self.has_context:
            raise ValueError('Context is already set')
        self.batch_size = context.batch_size
        self.seed = context.seed
        if self.name is None:
            self.name = '{}_{}'.format(self.__class__.__name__.lower(), self.seed)

    def get_batch(self, batch_index, output_names=None):
        """Return a batch from the stores of the pool.

        Parameters
        ----------
        batch_index : int
        output_names : list
            which outputs to include to the batch

        Returns
        -------
        batch : dict

        """
        output_names = output_names or self.output_names
        batch = dict()
        for output in output_names:
            store = self.stores[output]
            if store is None:
                continue
            if batch_index in store:
                batch[output] = store[batch_index]
        return batch

    def add_batch(self, batch, batch_index):
        """Add the outputs from the batch to their stores."""
        for (node, values) in batch.items():
            if node not in self.stores:
                continue
            store = self._get_store_for(node)
            if batch_index in store:
                continue
            store[batch_index] = values

    def remove_batch(self, batch_index):
        """Remove the batch from all stores."""
        for store in self.stores.values():
            if batch_index in store:
                del store[batch_index]

    def has_store(self, node):
        """Check if `node` is in stores."""
        return node in self.stores

    def get_store(self, node):
        """Return the store for `node`."""
        return self.stores[node]

    def add_store(self, node, store=None):
        """Add a store object for the node.

        Parameters
        ----------
        node : str
        store : dict, StoreBase, optional

        """
        if node in self.stores and self.stores[node] is not None:
            raise ValueError("Store for '{}' already exists".format(node))
        store = store if store is not None else self._make_store_for(node)
        self.stores[node] = store

    def remove_store(self, node):
        """Remove and return a store from the pool.

        Parameters
        ----------
        node : str

        Returns
        -------
        store
            The removed store

        """
        store = self.stores.pop(node)
        return store

    def _get_store_for(self, node):
        """Get or make a store."""
        if self.stores[node] is None:
            self.stores[node] = self._make_store_for(node)
        return self.stores[node]

    def _make_store_for(self, node):
        """Make a default store for a node.

        All the default stores will be created through this method.
        """
        return {}

    def __len__(self):
        """Return the largest batch index in any of the stores."""
        largest = 0
        for (output, store) in self.stores.items():
            if store is None:
                continue
            largest = max(largest, len(store))
        return largest

    def __getitem__(self, batch_index):
        """Return the batch."""
        return self.get_batch(batch_index)

    def __setitem__(self, batch_index, batch):
        """Add `batch` into location `batch_index`."""
        return self.add_batch(batch, batch_index)

    def __contains__(self, batch_index):
        """Check if the pool contains `batch_index`."""
        return len(self) > batch_index

    def clear(self):
        """Remove all data from the stores."""
        for store in self.stores.values():
            store.clear()

    def save(self):
        """Save the pool to disk.

        This will use pickle to store the pool under self.path.
        """
        if not self.has_context:
            raise ValueError('Pool context is not set, cannot save. Please see the set_context method.')
        os.makedirs(self.path, exist_ok=True)
        cwd = os.getcwd()
        os.chdir(self.path)
        for (node, store) in self.stores.items():
            filename = node + '.pkl'
            try:
                pickle.dump(store, open(filename, 'wb'))
            except BaseException:
                raise IOError('Failed to pickle the store for node {}, please check that it is pickleable or remove it before saving.'.format(node))
        os.chdir(cwd)
        stores = self.stores
        self.stores = dict.fromkeys(stores.keys())
        filename = os.path.join(self.path, self._pkl_name)
        pickle.dump(self, open(filename, 'wb'))
        self.stores = stores

    def close(self):
        """Save and close the stores that support it.

        The pool will not be usable afterwards.
        """
        self.save()
        for store in self.stores.values():
            if hasattr(store, 'close'):
                store.close()

    def flush(self):
        """Flush all data from the stores.

        If the store does not support flushing, do nothing.
        """
        for store in self.stores.values():
            if hasattr(store, 'flush'):
                store.flush()

    def delete(self):
        """Remove all persisted data from disk."""
        for store in self.stores.values():
            if hasattr(store, 'close'):
                store.close()
        if self.path is None:
            return
        elif not os.path.exists(self.path):
            return
        shutil.rmtree(self.path)

    @classmethod
    def open(cls, name, prefix=None):
        """Open a closed or saved ArrayPool from disk.

        Parameters
        ----------
        name : str
        prefix : str, optional

        Returns
        -------
        ArrayPool

        """
        prefix = prefix or _default_prefix
        path = cls._make_path(name, prefix)
        filename = os.path.join(path, cls._pkl_name)
        pool = pickle.load(open(filename, 'rb'))
        cwd = os.getcwd()
        os.chdir(path)
        for node in list(pool.stores.keys()):
            filename = node + '.pkl'
            try:
                store = pickle.load(open(filename, 'rb'))
            except Exception as e:
                logger.warning('Failed to load the store for node {}. Reason: {}'.format(node, str(e)))
                del pool.stores[node]
                continue
            pool.stores[node] = store
        os.chdir(cwd)
        pool.name = name
        pool.prefix = prefix
        return pool

    @classmethod
    def _make_path(cls, name, prefix):
        return os.path.join(prefix, name)

    @property
    def path(self):
        """Return the path to the pool."""
        if self.name is None:
            return None
        return self._make_path(self.name, self.prefix)
```
</details>
<!---Documatic-block-elfi.store.OutputPool-end--->
<!---Documatic-section-OutputPool-end--->

# #
<!---Documatic-section-elfi.store.OutputPool-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)